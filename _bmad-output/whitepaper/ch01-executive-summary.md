# 第一章：执行摘要

> **本章为快速阅读通道。** 技术决策者可以在 5 分钟内获取平台的核心价值主张和关键技术差异。

---

## 1.1 边缘计算的价值悖论

边缘计算正在从概念验证走向规模部署。然而，多数企业在推进边缘项目时遭遇了同一个结构性矛盾：

**硬件占据了 70-80% 的项目预算，但 100% 的业务价值来自运行在硬件上的应用。**

一台配置了 NVIDIA A100 的边缘服务器，闲置在机柜里和一块砖头没有区别。只有当质检模型在上面运行、每天拦截数百件瑕疵品时，这台服务器才开始回报投资。

传统边缘/IoT 项目"重前期硬件、轻后期应用"的运营模式，导致应用的价值释放速度远低于预期——硬件部署 3 个月完成，应用推广却花了 18 个月。

**核心结论**：边缘计算平台的设计哲学必须从"面向硬件"转向"面向应用"。平台无法改变硬件的采购成本，但可以显著改变应用在硬件上释放价值的效率和速度。

---

## 1.2 产品定位

**基于 Kubernetes 应用抽象构建的云原生边缘智能管理平台，让 AI 应用和业务服务在异构边缘基础设施上持续释放价值。**

平台以应用的全生命周期为核心组织所有技术能力。每一项技术能力都不是孤立的功能点，而是应用在某个生命周期阶段面对的具体问题的解法。

---

## 1.3 核心价值主张

### 应用即价值

应用商店 + 审核上架 + 一键分发到任意边缘，让应用的价值随业务演进持续释放。

- **三层应用资源模型**：Application → ApplicationVersion → ApplicationDeployment，应用定义与部署实例完全解耦
- **可插拔 Provisioner**：Workload（标准容器）、Helm（复杂多组件）、Model（AI 推理）三种部署引擎，统一管理接口
- **应用商店审核机制**：Workspace 开发 → 平台审核 → 全域可见，借鉴 App Store 模式实现跨团队应用共享
- **Topology-Based 部署**：一个声明式资源管理应用在所有边缘站点的部署，50 个站点的推广与 5 个站点的操作步骤完全相同

### 算力为应用服务

9 大 GPU 厂商统一调度，应用无需感知底层硬件差异。

- **四层 CRD 抽象**：DeviceModel（硬件规格）→ ComputeTemplate（切分配比）→ ResourcePool（资源池）→ NodeConfig（节点配置），从物理设备到可分配算力的完整管线
- **双模 GPU 虚拟化**：MIG 硬切分（硬件级隔离）+ HAMi-Core 软切分（全厂商通用），GPU 利用率从 <50% 提升到 ~92%
- **9 大厂商覆盖**：NVIDIA、海光、昇腾、沐曦、昆仑芯、平头哥、天数智芯、燧原、寒武纪，应用定义不包含任何硬件细节

### 管得住

五层权限模型，不同团队安全共享应用平台。

- **五层 Scope 授权**：Platform → Cluster → Workspace → NodeGroup → Namespace，映射企业组织架构
- **授权缓存优化**：TTL 300s + CRD 变化触发失效，兼顾性能与一致性
- **内置 OAuth2/OIDC**：JWT Token 生命周期管理、LoginRecord 审计记录、bcrypt 密码加密

### 断不了

边缘离线自治，应用持续运行不受网络影响。

- **三种离线方案**：KubeEdge（嵌入式边缘）、OpenYurt（标准服务器边缘）、VCluster（独立边缘集群），适配不同场景
- **可插拔运行时**：ComponentInstaller 接口 + init() 注册，新增运行时只需一个文件
- **分层镜像缓存**：Registry → ClusterRegistry → Repository → Node，四级分发确保弱网环境下镜像可用

---

## 1.4 关键技术指标

| 维度 | 指标 |
|------|------|
| **集群管理** | 支持 1000+ 集群联邦管理 |
| **节点规模** | 单集群 10000+ 节点 |
| **GPU 厂商** | 9 大厂商原生支持 |
| **GPU 虚拟化** | 单卡最多 20 份切分 |
| **应用管理** | 三种 Provisioner 覆盖全谱系应用类型 |
| **监控指标** | 291+ 预定义指标 |
| **权限层级** | 5 层 Scope 授权模型 |
| **CRD 体系** | 5 个 API 组、20+ CRD 类型 |

---

## 1.5 技术架构概览

```
┌──────────────────────────────────────────────────────────────┐
│                     云端控制面                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐   │
│  │ edge-apiserver│  │edge-controller│  │  edge-console    │   │
│  │              │  │              │  │  (Next.js 14)    │   │
│  │ 6 层 Filter  │  │ 8 个核心     │  │ 85+ React Hooks  │   │
│  │ Chain        │  │ Controller   │  │ 304 API 函数     │   │
│  └──────┬───────┘  └──────┬───────┘  └──────────────────┘   │
│         │                 │                                   │
│         ▼                 ▼                                   │
│  ┌──────────────────────────────┐  ┌──────────────────────┐ │
│  │   5 个 API 组 / 20+ CRD     │  │  monitoring-service  │ │
│  │   Scope | IAM | App |       │  │  291+ 预定义指标     │ │
│  │   Device | Registry         │  └──────────────────────┘ │
│  └──────────────────────────────┘                           │
├──────────────────────────────────────────────────────────────┤
│                     集群连接层                                │
│        Direct（直连）    ▏    Proxy（反向隧道）              │
├──────────────────────────────────────────────────────────────┤
│                     边缘数据面                                │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐               │
│  │ 北京工厂   │  │ 上海工厂   │  │ 广州工厂   │    ...       │
│  │ K8s 集群  │  │ K8s 集群  │  │ K8s 集群  │               │
│  │ + Edge    │  │ + Edge    │  │ + Edge    │               │
│  │   Agent   │  │   Agent   │  │   Agent   │               │
│  │ + 本地    │  │ + 本地    │  │ + 本地    │               │
│  │   缓存    │  │   缓存    │  │   缓存    │               │
│  └───────────┘  └───────────┘  └───────────┘               │
└──────────────────────────────────────────────────────────────┘
```

---

## 1.6 应用生命周期全景

平台以应用的全生命周期为主线组织所有技术能力：

| 阶段 | 应用面对的问题 | 平台的解法 | 详见 |
|------|-------------|-----------|------|
| **基础设施就绪** | 硬件怎么快速接入？集群怎么建？ | OTA 批量接入 + 集群联邦 + 分层镜像分发 | 第三章 |
| **算力就绪** | 异构 GPU 怎么统一使用？ | 四层 CRD 抽象 + 双模虚拟化 | 第四章 |
| **组织与安全** | 多团队怎么安全共享平台？ | 5 层权限模型 + 多租户隔离 | 第五章 |
| **应用供应链** | 应用怎么打包？怎么审核上架？ | Provisioner 插件 + 应用商店审核 | 第六章 |
| **应用部署** | 怎么部署到多个边缘？ | Topology-Based 部署 + 批量版本切换 | 第七章 |
| **应用运行** | 断网了怎么办？ | 边缘离线自治 + IoT CRD 云原生化 | 第八章 |
| **应用可观测** | 怎么知道应用健康不健康？ | 291+ 指标 + 多租户隔离 + 告警 | 第九章 |

---

## 1.7 与传统方案的本质区别

**传统边缘平台讲的故事**：我们支持什么硬件、管理多少节点、提供什么运行时。

**本平台讲的故事**：你的应用在边缘的每个阶段都有解法——打包、审核、部署、运行、监控——无论底层硬件怎么变。

这不是措辞差异，而是产品哲学的根本不同：

| 维度 | 传统边缘平台 | 本平台 |
|------|------------|--------|
| 核心抽象 | 设备/节点/集群 | 应用/版本/部署 |
| 技术组织方式 | 按基础设施分类 | 按应用生命周期阶段组织 |
| GPU 管理视角 | "支持多少种 GPU" | "应用的算力需求如何被透明满足" |
| 部署模型 | 每个站点独立操作 | 一个声明覆盖所有站点 |
| 权限模型 | 租户 + 项目二级 | Platform → Cluster → Workspace → NodeGroup → Namespace 五级 |
| 应用共享 | 无内置机制 | 应用商店 + 审核 + 全域可见 |

---

## 1.8 阅读路径建议

| 角色 | 推荐阅读路径 |
|------|-------------|
| **CTO / CIO / 技术决策者** | 第一章（本章）→ 第二章（立论）→ 第十一章（竞品对比） |
| **架构师** | 第二章 → 第三至九章（应用全生命周期）→ 第十章（架构设计） |
| **运维工程师** | 第三章（基础设施）→ 第七章（部署）→ 第九章（可观测） |
| **AI / 算力工程师** | 第四章（算力就绪）→ 第六章（模型部署）→ 第九章（GPU 监控） |
| **安全 / 合规负责人** | 第五章（组织与安全）→ 第十章（架构设计） |

---

*下一章：第二章 — 从硬件投入到应用价值，边缘计算的范式转移*
