# 二、核心差异化优势提炼（源码实证）

从源码和产品哲学中提炼出 **7 大差异化优势**，其中第 0 项是贯穿全文的核心叙事主线：

---

## 0. 应用价值驱动的平台哲学（最核心洞察 — 白皮书叙事主线）

**这不是一个技术差异点，而是整篇白皮书的立论基础。**

### 核心观点

**价值重心从硬件前置投入转向应用持续释放。**

传统边缘计算/IoT 的成本结构是"重前期、轻后期"——硬件一次性投入巨大（边缘服务器、GPU 卡、网关设备），但真正为企业产生业务价值的是运行在这些硬件上的**应用**。而应用的价值是随业务演进、模型升级、算法迭代**逐步释放**的。

因此，平台的设计哲学必须**面向应用**，而不是面向设备或硬件。

### 三层论证

#### 论点一：价值在应用层，不在硬件层

```
传统 IoT 投入结构:
┌─────────────────────────────────────────────────┐
│  硬件投入（一次性）         │  应用价值（持续性）   │
│  ████████████████████       │  ░░░░░░░░░░░░░░░░░   │
│  占成本 70-80%              │  产生价值 100%        │
│  边缘服务器、GPU、网关       │  AI 推理、数据分析、  │
│  交换机、传感器              │  业务流程、模型升级   │
└─────────────────────────────────────────────────┘

关键矛盾:
  成本集中在硬件 → 但价值来自应用
  硬件一次性部署 → 但应用持续演进
  硬件形态会变化 → 但应用抽象可延续
```

- 一台边缘服务器的价值不在于它有多少 GPU 核心，而在于上面运行的质检模型每天帮工厂拦截了多少次废品
- 一个边缘集群的价值不在于它管理了多少节点，而在于它承载的应用组合为业务创造了多少收入
- 硬件是沉没成本，应用是持续回报

#### 论点二：Kubernetes 的应用抽象是最佳载体

既然价值在应用层，那平台就应该围绕应用来构建。K8s 作为事实标准，提供了最成熟的应用抽象：

| K8s 应用抽象 | 解决的问题 | 本平台的扩展 |
|-------------|-----------|-------------|
| 声明式 API | 应用"是什么"而非"怎么做" | Application CRD + Provisioner 插件 |
| 工作负载模型 | Deployment/StatefulSet/DaemonSet 生命周期 | Topology-Based 云边混合部署 |
| Helm Chart | 应用打包与版本管理 | 应用商店 + 审核上架 + 版本升降级 |
| Namespace 隔离 | 多租户应用隔离 | 5 层 Scope 权限模型 |

**关键推论**：基于 K8s 构建的平台天然面向未来价值释放，而不是被当下的硬件形态锁定。硬件换了（从 NVIDIA 换成昇腾），应用定义不变；边缘运行时换了（从 KubeEdge 换成 OpenYurt），应用部署方式不变。

#### 论点三：物模型等 IoT 能力已被云原生生态吸收

传统 IoT 的核心能力（物模型、设备管理、消息路由等）并没有被抛弃，而是被 EdgeX Foundry、OpenYurt、KubeEdge 等开源项目以云原生方式**重新实现**。

关键区别在于——这些能力是**基于逻辑抽象**而非厂商私有实现：

```
传统 IoT:
  物模型 → 厂商私有 SDK → 被锁定在特定平台
  设备管理 → 私有协议 → 换平台就要重写
  应用部署 → 手工安装 → 无法规模化

云原生边缘:
  物模型 → EdgeX Foundry CRD → 标准 K8s API 操作
  设备管理 → KubeEdge/OpenYurt Device CRD → 声明式管理
  应用部署 → Helm/K8s Deployment → 一键分发到任意边缘
```

**未来迭代和发展不受制于人。**

### 白皮书价值

这个洞察决定了白皮书的**叙事结构**：

- **不是**"我们有什么技术" → **而是**"我们解决什么价值问题"
- **不是**"我们支持 9 种 GPU" → **而是**"让你的 AI 应用无视硬件差异，持续释放价值"
- **不是**"我们有 5 层权限" → **而是**"让不同团队安全地共享应用平台，加速价值交付"

所有技术能力（异构算力、多集群、权限模型等）都应该作为"应用价值持续释放"这个核心叙事的**支撑论据**，而不是独立的技术卖点。

### 源码映射

这个哲学在源码中的具体体现：

| 哲学观点 | 源码证据 |
|---------|---------|
| 应用是一等公民 | Application/ApplicationVersion/ApplicationDeployment 三层 CRD 体系 |
| 应用与硬件解耦 | Provisioner 插件模式（workload/helm/model），应用定义不含硬件细节 |
| 应用可跨边缘分发 | Topology-Based 部署，同一应用 → 多个 nodeGroup → 自动创建 K8s Deployment |
| 应用商店生态 | ReviewPhase 审核流程，workspace 级开发 → 平台级分享 |
| 硬件变化不影响应用 | DeviceModel 抽象层，NodeConfig 按厂商独立配置，应用无感知 |
| IoT 能力云原生化 | iot.theriseunion.io CRD，设备管理通过 K8s 标准 API |

---

## 1. 异构算力统一调度（最大技术差异点）

**源码证据**：`api/device/v1alpha1/` 定义了完整的 GPU 设备管理 CRD 体系

- **9 大厂商适配**：NVIDIA、海光(Hygon)、昇腾(Ascend)、摩尔线程(Metax)、昆仑芯(Kunlunxin)、阿里巴巴、天数智芯(Iluvatar)、燧原(Enflame)、寒武纪(Cambricon)
- **双模切分**：
  - **硬切分（MIG）**：`ComputeSplitMode: "hard"` — 硬件级 GPU 分区，`MigTemplates [][]MigTemplate` 二维数组支持多模板集
  - **软切分（HAMi-Core）**：`ComputeSplitMode: "soft"` — 软件级虚拟化，支持 1-20 任意切分
- **算力超分**：`deviceMemoryScaling` / `deviceCoreScaling` 支持内存和算力的超额配置
- **资源池架构**：`ResourcePool` + `ResourcePoolItem` CRD，支持 shared/dedicated/reserved 三种策略
- **精度级算力定义**：`ComputeCapability` 结构支持 FP32/FP16/BF16/FP8 多精度 TFLOPS 定义

**白皮书价值**：这是竞品对比中最突出的技术优势。华为 IEF 仅支持 CPU/GPU/NPU，阿里 ACK@Edge 支持多硬件但无虚拟化，本平台实现了从硬件抽象、虚拟化切分到调度分配的全链路管理。

## 2. 多层级权限模型（K8s RBAC 的生产级扩展）

**源码证据**：`internal/authorizer/authorizer.go` 实现了 5 层 Scope 链

```
Platform(全局) → Cluster → Workspace → NodeGroup → Namespace
```

- 兼容 K8s 标准 `authorizer.Attributes` 接口
- `SimpleCache` + TTL(300s) 性能优化
- `CacheInvalidator` 监听 CRD 变化自动失效
- 支持跨集群权限继承
- IAM CRD 包括：User、IAMRole、IAMRoleBinding、RoleTemplate、Category、ScopePattern、LoginRecord

**白皮书价值**：区别于竞品的"租户+项目"二级模型，本平台实现了业界最细粒度的 5 层权限体系，可满足大型企业组织架构映射。

## 3. 可插拔应用供应体系（Provisioner 模式）

**源码证据**：`api/app/v1alpha1/` 中 `ApplicationVersion` 支持三种 Provisioner

- **Workload Provisioner**：原生 K8s Deployment 部署
- **Helm Provisioner**：Helm Chart 版本化管理，支持审核流程（`ReviewPhase: Pending/Approved/Rejected`）
- **Model Provisioner**：AI 模型部署（PyTorch/TensorFlow/ONNX），含 `ModelConfig` 结构

**白皮书价值**：Application CRD 采用类似 PVC 的设计模式，通过 Label `app.theriseunion.io/provisioner` 路由到不同供应器，实现了"一个应用抽象，多种部署方式"。

## 4. CRD 驱动的全声明式架构

**源码证据**：5 个 API 组、20+ CRD 类型全部基于 `controller-runtime`

- **Scope 组**：Cluster、Workspace、NodeGroup — 资源管理层级
- **IAM 组**：User、IAMRole、IAMRoleBinding 等 — 权限管理
- **App 组**：Application、ApplicationVersion、ApplicationDeployment — 应用全生命周期
- **Device 组**：DeviceModel、ComputeTemplate、ResourcePool、NodeConfig、GlobalConfig — 算力管理
- **Registry 组**：Registry、Repository、ClusterRegistry、ClusterRepository — 镜像管理

每个 CRD 都有对应的 Controller 进行 Reconcile，Finalizer 管理资源清理，Condition 跟踪状态变化。

## 5. OpenAPI 驱动的全链路类型安全

**源码证据**：前后端通过 OpenAPI Schema 自动桥接

```
后端 go-restful + go-restful-openapi → /openapi/v2 端点
                     ↓
              openapi.json 文件
                     ↓
         Kubb 代码生成器（pnpm codegen）
                     ↓
     304 个类型安全的 API 客户端函数 + 400+ TypeScript 类型
                     ↓
           85+ 自定义 React Hook 封装
                     ↓
              36+ 功能组件模块
```

**白皮书价值**：这种架构确保了从 CRD 定义到前端 UI 的完整类型一致性，API 变更后自动生成客户端代码，消除了前后端接口不一致的问题。

## 6. 分层镜像同步与多架构支持

**PDF 证据**：统一应用管理的镜像同步架构

- 总部管控集群 → 云端统一入口 → 分部镜像缓存 Job → 边缘节点主动缓存
- 同时支持 x86 和 ARM 架构的边缘节点
- 基于 Harbor 的分级镜像仓库体系

---
